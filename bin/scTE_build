#!/usr/bin/env python

import multiprocessing
from functools import partial
import logging
import os, sys, glob, datetime, time, gzip
import argparse
import collections
from math import log
sys.path.append(os.path.join(os.path.split(sys.argv[0])[0], '../'))
from scTE.miniglbase import genelist, glload, location

chr_list = [ str(k) for k in  list(range(1,50))] + ['X','Y'] # delete M, MT

def read_opts(parser):
    args = parser.parse_args()

    if args.mode not in ['inclusive', 'exclusive'] :
        logging.error("Counting mode %s not supported\n" % (args.mode))
        parser.print_help()
        sys.exit(1)

    if args.genome not in ['mm10', 'hg38'] :
        logging.error("Counting mode %s not supported\n" % (args.genome))
        parser.print_help()
        sys.exit(1)

    args.info = logging.info
    return args

def cleanexon(exons):
    tmp = []
    for k in sorted(exons):
        E=[]
        for it in exons[k]:
            E+=list(range(it[1],it[2]))
        E=sorted(set(E))

        s=0
        #tmp=[]
        for id in range(0,len(E)-1):
            if E[id+1]-E[id] >1:
                en=id
                tmp.append({'loc': location(chr=it[0], left=E[s], right=E[en]), 'annot': k}) #[E[s],E[en]])
                s=en+1
        tmp.append({'loc': location(chr=it[0], left=E[s], right=E[id+1]), 'annot': k}) # [E[s],E[id+1]])

    return tmp

def genomeIndex(genome, mode, geneurls, teurls):

    os.system('wget -c %s'%geneurls)
    os.system('wget -c %s'%teurls)
    
    #Download twice for double check, as sometines wget may stops on the way
    os.system('wget -c %s'%geneurls)
    os.system('wget -c %s'%teurls)

    geneform ={'force_tsv': True, 'loc': 'location(chr=column[0], left=column[1], right=column[2])', 'annot': 3}
    teform ={'force_tsv': True, 'loc': 'location(chr=column[5], left=column[6], right=column[7])', 'annot': 10}

    genefilename = geneurls.split('/')[-1:][0]
    tefilename = teurls.split('/')[-1:][0]

    raw = {}
    clean = {}
    if '.gz' in genefilename:
        o = gzip.open(genefilename,'rb')
    else:
        o = open(genefilename,'r')

    for idx, l in enumerate(o):
        if '.gz' in genefilename:
            l=l.decode('ascii')
        if l.startswith('#'):
            continue
        t=l.strip().split('\t')
        if t[2]=='exon' or t[2]=='UTR':
            chr = t[0]
            left = int(t[3])
            riht =  int(t[4])
            name=t[8].split('gene_name "')[1].split('";')[0]

            if name not in raw:
                raw[name] = []
            raw[name].append([chr,left,riht])

            if 'protein_coding' not in l and 'lincRNA' not in l:
                continue
            if name not in clean:
                clean[name] = []
            clean[name].append([chr,left,riht])

    o.close()

    raw = cleanexon(raw) 
    clean = cleanexon(clean) 
    
    gls = genelist()
    gls.load_list(clean)
    
    if mode == 'exclusive':
        gene = {}
        for l in clean:
            chr = l['loc'].loc['chr'] 
            if chr not in chr_list:
                continue
            left = l['loc']['left']
            rite = l['loc']['right']

            left_buck = ((left-1)//10000) * 10000
            right_buck = (rite//10000) * 10000
            buckets_reqd = range(left_buck, right_buck+10000, 10000)

            if chr not in gene:
                gene[chr] = {}

            if buckets_reqd:
                for buck in buckets_reqd:
                    if buck not in gene[chr]:
                        gene[chr][buck] = []
                    gene[chr][buck].append([left, rite])

        # Process the TEs:
        noverlap = []
        if '.gz' in tefilename:
            o = gzip.open(tefilename,'rb')
        else:
            o = open(tefilename,'rU')

        for n, l in enumerate(o):
            if '.gz' in tefilename:
                l = l.decode('ascii')
            t = l.strip().split('\t')
            chr = t[5].replace('chr', '')
            
            if chr not in chr_list:
                continue
            
            if chr not in gene: # Should be very rare
                noverlap.append({'loc': location(chr=chr, left=left, right=rite), 'annot': t[10]})
                continue
            
            left = int(t[6])
            rite = int(t[7])

            left_buck = ((left-1)//10000) * 10000
            right_buck = (rite//10000) * 10000
            buckets_reqd = range(left_buck, right_buck+10000, 10000)

            if buckets_reqd:
                i = 1
                for buck in buckets_reqd:
                    if buck not in gene[chr]:
                        pass
                    else:
                        for k in gene[chr][buck]:
                            if left < k[1] and rite > k[0]:
                                i = 0
                                break
                        if i == 0: # already found an overlap, so quit out;
                            break
                if i == 1:
                    noverlap.append({'loc': location(chr=chr, left=left, right=rite), 'annot': t[10]})
        
        TEs = genelist()
        TEs.load_list(noverlap)
        
        genes = genelist() 
        genes.load_list(raw)

        all_annot = genes + TEs
        all_annot.save('%s.exclusive.glb'%genome)

    elif mode == 'inclusive':
        genes = genelist() 
        genes.load_list(raw)

        if tefilename.endswith('.gz'):
            TEs = genelist(tefilename, format=teform, gzip=True)
        else:
            TEs = genelist(tefilename, format=teform)
        
        all_annot = genes + TEs
        all_annot.save('%s.inclusive.glb'%genome)
    
    os.system('rm %s %s'%(genefilename,tefilename))

def prepare_parser():
    
    desc = "Build genome annotation index for scTE"

    exmp = "Example: scTE_build -g mm10"
    
    parser = argparse.ArgumentParser(prog='scTE_build',description=desc, epilog=exmp)
    
    parser.add_argument('-m','--mode', metavar='TEs counting mode', dest='mode', nargs='?', type=str,
                        default='exclusive', choices=['inclusive','exclusive'],
                        help='How to count TEs expression: inclusive (inclued all reads that can map to TEs), or exclusive (exclued the reads that can map to protein coding genes and lncRNAs).\
                        DEFAULT: exclusive')

    parser.add_argument('-g','--genome', metavar='genome', dest='genome',type=str, nargs='?', choices=['hg38','mm10',],required=True,
                        help='Possible Genomes: mm10 (mouse), hg38 (human)')
    
    return parser

def main():

    timestart=datetime.datetime.now()
    args=read_opts(prepare_parser())

    assert sys.version_info >= (3, 6), 'Python >=3.6 is required'

    info = args.info

    info("Building the scTE genome annotation index... %s"%(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
    
    if args.genome == 'mm10':
        genomeIndex(args.genome,args.mode,
                    'ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M21/gencode.vM21.annotation.gtf.gz',
                    'http://hgdownload.soe.ucsc.edu/goldenPath/mm10/database/rmsk.txt.gz')
    
    elif args.genome == 'hg38':
        genomeIndex(args.genome,args.mode,
                    'ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_30/gencode.v30.annotation.gtf.gz',
                    'http://hgdownload.soe.ucsc.edu/goldenPath/hg38/database/rmsk.txt.gz')

    info("Done genome annotation index building... %s"%(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")))

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        sys.stderr.write("User interrupt !\n")
        sys.exit(0)



