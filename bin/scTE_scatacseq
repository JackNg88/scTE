#!/usr/bin/env python
desc = '''

The scATAC-seq data comes as three files, P1, P2 and the barcode, and there is no UMI

You can just align P1 and P2 with your favourite aligner (we prefer STAR with these settings):

****
teopts=' --outFilterMultimapNmax 100 --winAnchorMultimapNmax 100 --outSAMmultNmax 1 --outSAMtype BAM SortedByCoordinate --twopassMode Basic --outWigType wiggle --outWigNorm RPM'
opts='--runRNGseed 42 --runThreadN 12 --readFilesCommand zcat '

genome_mm10='--genomeDir mm10_gencode_vM21_starsolo/SAindex'
genome_hg38='--genomeDir hg38_gencode_v30_starsolo/SAindex'

# p1 = read
# p2 = barcode and UMI
# Make sure you set the correct genome index;
STAR $opts $teopts $genome_hg38 --outFileNamePrefix ss.${out} --readFilesIn ${p1} ${p2}
****

This script will then reprocess the BAM file, and put the BARCODE into CR SAM tag and spoof a UMI

The UMI is generated by incrementing the sequence, so, each UMI is up to 4^14 (26 million).
I guess there remains a change of a clash, but it should be so rare
as to be basically impossible.

Keep in mind though that downstream UMI statistics are inaccurate

Require pysam

'''
import sys, os
import gzip
import argparse
import logging
try:
    import pysam
except ImportError:
    print('pack_scatacseq requires pysam')
    sys.quit()

sys.path.append(os.path.join(os.path.split(sys.argv[0])[0], '../'))
from scTE.scatacseq import build_barcode_dict, parse_bam, load_expected_whitelist

# Command-line options;
def prepare_parser():
    exmp = 'scTE_scatacseq -i in.bam -f fastq.fastq[.gz] -o out.bam -w observed_whitelist.txt [-e expected_whitelist.txt]'

    description = 'Package the BAM and BARCODE for the scATAC-seq data to make it suitable for scTE main pipeline'

    description = 'dummy'

    parser = argparse.ArgumentParser(prog='scTE_scatacseq', description=description, epilog=exmp)
    # Optional:
    optional = parser._action_groups.pop()
    optional.add_argument('-e', '--expwhite', nargs=1, required=False, help='A txt file containing the expected whitelist of barcodes to correct the observed barcodes with')
    optional.add_argument('--ondisk', action='store_true', required=False, help='Do everything in memory (faster, but you will need a lot!, or do it on disk (slower, but no memory requirement')

    required = parser.add_argument_group('required arguments')

    required.add_argument('-i', '--inbam', nargs=1, required=True, help='the BAM alignment file to add barcode and UMI tags to')
    required.add_argument('-f', '--infastq', nargs=1, required=True, help='THe FASTQ file containing the barcode read')
    required.add_argument('-o', '--outbam', nargs=1, required=True, help='the BAM alignment file to save the result into')
    required.add_argument('-w', '--obswhite', nargs=1, required=True, help='A txt file to save the observed barcode whitelist to')

    parser._action_groups.append(optional)

    logging.basicConfig(level=logging.DEBUG,
                    format='%(levelname)-8s: %(message)s',
                    datefmt='%m-%d %H:%M')

    parser.log = logging.getLogger('scTE_scatacseq')

    return parser

def main():
    assert sys.version_info >= (3, 6), 'Python >=3.6 is required'

    parser = prepare_parser()
    args = parser.parse_args()

    logger = parser.log

    logger.info('Arguments:')
    logger.info('  inbam: %s' % args.inbam[0])
    logger.info('  infastq: %s' % args.infastq[0])
    logger.info('  outbam: "%s"' % args.outbam[0])
    logger.info('  observed whitelist: "%s"' % args.obswhite[0])
    if args.expwhite:
        logger.info('  expected whitelist: "%s"' % args.expwhite[0])
    logger.info('  On disk: %s' % args.ondisk)

    expected_whitelist = None
    if args.expwhite:
        expected_whitelist = load_expected_whitelist(args.expwhite[0], logger=logger)

    logger.info('Building barcode whitelist')
    barcode_lookup, barcode_corrector, tmpfilename = build_barcode_dict('atac_pbmc_10k_v1_S1_L001_R2_001.fastq.gz', 'whitelist.tsv', expected_whitelist=expected_whitelist, logger=logger, ondisk=args.ondisk)

    logger.info('Parsing BAM')
    parse_bam(infile=args.inbam, outfile=args.outbam[0], barcode_lookup=barcode_lookup, barcode_corrector=barcode_corrector, logger=logger)

    if args.ondisk: # Cleanup the DB
        os.remove(tmpfilename)

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        sys.stderr.write("User interrupt\n")
        sys.exit(0)
